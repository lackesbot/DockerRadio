<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LUG Radio</title>
<style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Left panel */
    #panel {
      position: absolute;
      top: 10px; left: 0;
      z-index: 10;
      background: rgba(0,0,0,0.85);
      color: white;
      font-family: sans-serif;
      padding: 12px;
      border-radius: 0 8px 8px 0;
      width: 280px;
      max-height: 90vh;
      overflow-y: auto;
      transition: opacity 0.3s ease;
    }
    #panel.hidden { opacity: 0; pointer-events: none; }

    #panel h1 { margin: 0 0 10px 0; font-size: 20px; }
    #panel h2 { margin: 8px 0 4px; font-size: 16px; border-bottom: 1px solid #444; }
    #panel button, #panel select {
      margin: 4px 0;
      padding: 6px 10px;
      width: 100%;
      background: #222;
      color: white;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
    }
    #panel button:hover, #panel select:hover { background: #444; }
    #panel input[type=range] {
      margin: 4px 0;
      width: 90%;
      display: block;
    }
    #hint {
      margin-top: 6px;
      font-size: 12px;
      color: #aaa;
      text-align: center;
    }
    ul { padding-left: 15px; margin: 5px 0; }
    li { margin: 3px 0; font-size: 14px; }
    li span.track { color: #aaa; font-size: 12px; }

    /* Right info drawer */
    #infoOverlay {
      position: fixed;
      top: 0; right: 0;
      width: 500px;
      height: 100%;
      background: rgba(0,0,0,0.95);
      color: white;
      font-family: sans-serif;
      transform: translateX(100%);
      transition: transform 0.3s ease, opacity 0.3s ease;
      z-index: 20;
      display: flex;
      flex-direction: column;
    }
    #infoOverlay.open { transform: translateX(0); }
    #infoOverlay.hidden { opacity: 0; pointer-events: none; }

    #infoTab {
      position: absolute;
      top: 3%;
      left: -30px;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.95);
      color: white;
      padding: 6px 8px;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      font-size: 14px;
      user-select: none;
    }

    #infoContent {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    #broadcastList { margin-top: 20px; }
    #broadcastList table {
      width: 100%;
      border-collapse: collapse;
    }
    #broadcastList th, #broadcastList td {
      border: 1px solid #555;
      padding: 6px;
      text-align: left;
      font-size: 14px;
    }
    #broadcastList th { background: #222; }
  </style>

  <script src="js/butterchurn.min.js" defer></script>
  <script src="js/butterchurnPresets.min.js" defer></script>
  <script defer>
  window.addEventListener('DOMContentLoaded', () => {
    const audio = document.getElementById('audio');
    const canvas = document.getElementById('visualizer');
    const streamSelect = document.getElementById('streamSelect');
    const broadcastsDiv = document.getElementById('broadcasts');
    const externalBroadcastsDiv = document.getElementById('externalBroadcasts');
    const panel = document.getElementById('panel');
    const infoOverlay = document.getElementById('infoOverlay');
    const infoTab = document.getElementById('infoTab');
    const broadcastTableDiv = document.getElementById('broadcastTable');

    //audio context
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaElementSource(audio);
    const analyser = audioCtx.createAnalyser();
    source.connect(analyser);
    analyser.connect(audioCtx.destination);
    audio.volume = 0.15;
    const bc = window.butterchurn?.default || window.butterchurn;
    const presetsLib = window.butterchurnPresets?.default || window.butterchurnPresets;

    const viz = bc.createVisualizer(audioCtx, canvas, {
      width: window.innerWidth,
      height: window.innerHeight,
      meshDensity: 32,
      pixelRatio: window.devicePixelRatio || 1
    });
    viz.connectAudio(analyser);

    const presets = presetsLib.getPresets();
    const keys = Object.keys(presets);

    let shuffled = keys.map((_, i) => i);
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
    shuffleArray(shuffled);
    let shuffleIndex = 0;

    function loadNextPreset() {
      if (shuffleIndex >= shuffled.length) {
        shuffleArray(shuffled);
        shuffleIndex = 0;
      }
      viz.loadPreset(presets[keys[shuffled[shuffleIndex++]]], 2.0);
    }
    function loadPreviousPreset() {
      shuffleIndex = (shuffleIndex - 2 + shuffled.length) % shuffled.length;
      viz.loadPreset(presets[keys[shuffled[shuffleIndex++]]], 2.0);
    }
    loadNextPreset();

    //render loop for visualizer
    let vizEnabled = true;
    function renderFrame() {
      requestAnimationFrame(renderFrame);
      if (vizEnabled) viz.render();
    }
    renderFrame();

    //visualizer controls
    const toggleVizBtn = document.getElementById('toggleViz');
    toggleVizBtn.addEventListener('click', (e) => {
      vizEnabled = !vizEnabled;
      e.target.textContent = vizEnabled ? "Disable Visualizer" : "Enable Visualizer";
    });
    document.getElementById('nextPreset').addEventListener('click', loadNextPreset);
    document.getElementById('lastPreviousPreset').addEventListener('click', loadPreviousPreset);

    let cycleInterval = setInterval(loadNextPreset, 45000);
    const toggleCycleBtn = document.getElementById('toggleCycle');
    toggleCycleBtn.addEventListener('click', (e) => {
      if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
        e.target.textContent = "Enable Auto-Cycle";
      } else {
        cycleInterval = setInterval(loadNextPreset, 45000);
        e.target.textContent = "Disable Auto-Cycle";
      }
    });

    document.getElementById('fullscreen').addEventListener('click', () => {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    });

	streamSelect.addEventListener('change', () => {
	  audio.src = streamSelect.value;
	  audio.play().catch(()=>{});
  	  updateStatus();
	});

    document.getElementById('volume').addEventListener('input', (e) => {
      audio.volume = parseFloat(e.target.value);
    });

    function resyncStream() {
      const currentStream = streamSelect.value;
      audio.pause();
      audio.src = '';
      audio.load();
      setTimeout(() => {
        audio.src = currentStream;
        audio.play().catch(()=>{});
      }, 100);
    }
    document.getElementById('resync').addEventListener('click', resyncStream);
    audio.addEventListener('error', resyncStream);
    audio.addEventListener('stalled', resyncStream);
    audio.addEventListener('ended', resyncStream);

const externals = [
      { name: "WVCW - VCU", url: "https://wvcwradio.vcu.edu:8000/wvcw" },
      { name: "WCWM - W&M", url: "https://wcwm.broadcasttool.stream/wcwm-onair" },
      { name: "WTJU - UVA", url: "https://streams.wtju.net/wxtj-live.mp3"},
      //{ name: "WGMU - GMU", url: "http://wgmuradio.masonstudentmedia.com/listen.m3u"},
      { name: "WDCE - UoR", url: "https://das-edge14-live365-dal02.cdnstream.com/a39711?aw_0_1st.playerId=Live365-Widget&aw_0_1st.skey=1759340205350"}
      //{ name: "WUVT - V/T", url: "https://stream.wuvt.vt.edu/wuvt-hq.aac"}
    ];

    function renderExternalBroadcasts(currentVal, cur) {
      // EXTERNAL group
      const groupExternal = document.createElement("optgroup");
      groupExternal.label = "EXTERNAL Broadcasts";
      
      externals.forEach(ext => {
        const opt = document.createElement("option");
        opt.value = ext.url;
        const extHref = new URL(ext.url, window.location.href).href;
        const isCurrent = !!cur && cur.href === extHref;
        opt.textContent = ext.name;
        if (currentVal && currentVal === ext.url) opt.selected = true;
        groupExternal.appendChild(opt);
      });
      streamSelect.appendChild(groupExternal);

      // Panel external list
      let htmlExt = "<h2>[ External Broadcasts ]</h2><ul>";
      externals.forEach(ext => {
        const isCurrent = audio.src === ext.url;
        htmlExt += isCurrent
          ? `<li><strong>${ext.name}</strong></li>`
          : `<li>${ext.name}</li>`;
      });
      htmlExt += "</ul>";
      externalBroadcastsDiv.innerHTML = htmlExt;
    }

    function getCurrentURL() {
      try { return new URL(audio.currentSrc || audio.src, window.location.href); }
      catch { return null; }
    }

    async function updateStatus() {
      let sources = [];
      const cur = getCurrentURL();
      const currentVal = streamSelect.value;

      try {
        const resp = await fetch('http://localhost:8000/status-json.xsl');
        const data = await resp.json();
        if (data && data.icestats && data.icestats.source) {
            sources = data.icestats.source;
            if (!Array.isArray(sources)) sources = [sources];
        }
      } catch (e) {
        console.warn("Local broadcasts unavailable:", e);
        broadcastsDiv.innerHTML = "<h2>[ Local Broadcasts ]</h2><p style='padding-left:15px'>Nothing found (yet)</p>";
        if (broadcastTableDiv) broadcastTableDiv.textContent = "Broadcasts unavailable";
      }

      streamSelect.innerHTML = "";

      if (sources.length > 0) {
        // internal group
        const groupLocal = document.createElement("optgroup");
        groupLocal.label = "Local Broadcasts";
        sources.forEach((s, i) => {
          const url = new URL(s.listenurl, "http://localhost:8000");
          const path = url.pathname;
          const isCurrent = !!cur && cur.pathname === path;
          const opt = document.createElement("option");
          opt.value = "http://localhost:8000" + path;
          opt.textContent = s.server_name || path;
          if (currentVal && currentVal === opt.value) opt.selected = true;
          else if (!currentVal && i === 0) opt.selected = true;
          groupLocal.appendChild(opt);
        });
        streamSelect.appendChild(groupLocal);

        // Panel internal list
        let html = "<h2>[ Local Broadcasts ]</h2><ul>";
        sources.forEach(s => {
          const url = new URL(s.listenurl, "http://localhost:8000");
          const path = url.pathname;
          const isCurrent = audio.src.endsWith(path);
          const track = s.title ? ` — <span class="track">${s.title}</span>` : "";
          html += isCurrent
            ? `<li><strong>${s.server_name || path}${track}</strong></li>`
            : `<li>${s.server_name || path}${track}</li>`;
        });
        html += "</ul>";
        broadcastsDiv.innerHTML = html;

        // Info tab broadcast table
        if (broadcastTableDiv) {
          let table = "<table><tr><th>Station</th><th>HREF</th><th>Title</th><th>Artist</th><th>Listeners</th></tr>";
          sources.forEach(s => {
            const url = new URL(s.listenurl, "http://localhost:8000");
            table += `<tr>
              <td>${s.server_name || url.pathname}</td>
              <td>localhost:8000${url.pathname}</td>
              <td>${s.title || "-"}</td>
              <td>${s.artist || "-"}</td>
              <td>${s.listeners || 0}</td>
            </tr>`;
          });
          table += "</table>";
          broadcastTableDiv.innerHTML = table;
        }
      }

      renderExternalBroadcasts(currentVal, cur);

      // Default if nothing set
      if (!audio.src || audio.src === window.location.href) {
        if (sources.length > 0) {
          const firstPath = "http://localhost:8000" + new URL(sources[0].listenurl, "http://localhost:8000").pathname;
          audio.src = firstPath;
          audio.play().catch(()=>{});
        } else if (externals.length > 0) {
          audio.src = externals[0].url;
          audio.play().catch(()=>{});
        }
      }
    }

    setInterval(updateStatus, 10000);
    updateStatus();

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      viz.setRendererSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    document.body.addEventListener('click', () => audioCtx.resume());

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        panel.classList.toggle('hidden');
        infoOverlay.classList.toggle('hidden');
      }
    });

    // Hotkeys
    window.addEventListener('keydown', (e) => {
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
      switch (e.key) {
        case 'x': case 'X': loadNextPreset(); break;
        case 'z': case 'Z': loadPreviousPreset(); break;
        case 'f': case 'F': document.getElementById('fullscreen').click(); break;
        case 'g': case 'G': toggleVizBtn.click(); break;
        case 'h': case 'H': toggleCycleBtn.click(); break;
        case 'r': case 'R': document.getElementById('resync').click(); break;
        case 'Tab': e.preventDefault(); infoTab.click(); break;
        case 'ArrowRight': {
          let idx = streamSelect.selectedIndex;
          if (idx < streamSelect.options.length - 1) {
            streamSelect.selectedIndex = idx + 1;
            streamSelect.dispatchEvent(new Event('change'));
          }
          break;
        }
        case 'ArrowLeft': {
          let idx = streamSelect.selectedIndex;
          if (idx > 0) {
            streamSelect.selectedIndex = idx - 1;
            streamSelect.dispatchEvent(new Event('change'));
          }
          break;
        }
        case 'ArrowUp':
          audio.volume = Math.min(1, audio.volume + 0.05);
          document.getElementById('volume').value = audio.volume;
          break;
        case 'ArrowDown':
          audio.volume = Math.max(0, audio.volume - 0.05);
          document.getElementById('volume').value = audio.volume;
          break;
      }
    });

    infoTab.addEventListener('click', () => {
      infoOverlay.classList.toggle('open');
      infoTab.textContent = infoOverlay.classList.contains('open') ? ">>" : "<<";
    });
  });
  </script>
</head>
<body>
  <div id="panel">
    <h1>[ LUG Radio ]</h1>
    <div id="quote" style="margin:8px 0; font-size:13px; font-style:italic; color:#ccc;"></div>
    <div id="broadcasts">Loading broadcasts...</div>
    <div id="externalBroadcasts">Loading external broadcasts...</div>
    <label for="streamSelect">Tuned into:</label>
    <select id="streamSelect"></select>
    <button id="nextPreset">Next Visual (X)</button>
    <button id="lastPreviousPreset">Last Visual (Z)</button>
    <button id="fullscreen">Fullscreen (F)</button>
    <button id="toggleViz">Disable Visualizer (G)</button>
    <button id="toggleCycle">Disable Auto-Cycle (H)</button>
    <button id="resync">Resync (R)</button>

    <label for="volume">Volume:</label>
    <input type="range" id="volume" min="0" max="1" step="0.01" value=".15">
    <div id="hint"> ←/→ station | ↑/↓ volume | Tab info | Space fade UI</div>
  </div>

  <div id="infoOverlay">
    <div id="infoTab"><<</div>
    <div id="infoContent">
      <h2>[ LUG Radio ]</h2>
      <p id="infoDescription">Welcome to the VCU Linux User Group Docker Workshop! We'll use this website to access Docker radio broadcasts *you* get to set up! This website is a clean copy of my personal radio site <a href="https://radio.jfelix.space">[radio.jfelix.space]</a><br><br>An Icecast server broadcasting Liquidsoap generated audio streams.<br>Butterchurn is used for live visualizations.<br><br> REMEMBER: DO NOT PUBLICLY BROADCAST COPYRIGHT MUSIC WITHOUT A LICENSE!</p>
    </div>
  </div>

  <audio id="audio" crossorigin="anonymous" autoplay></audio>
  <canvas id="visualizer"></canvas>
</body>
</html>